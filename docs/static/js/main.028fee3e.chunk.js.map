{"version":3,"sources":["pull-to-refresh/index.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["DIRECTION","isScrollable","element","direction","overflowType","getComputedStyle","overflowY","document","scrollingElement","isOverflowScrollable","DOWN","scrollTop","clientHeight","scrollHeight","UP","Error","styleInject","css","ref","insertAt","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","RefreshingContent","React","className","PullingContent","PullToRefresh","_a","_b","refreshingContent","_c","pullingContent","_d","pullDownThreshold","_e","maxPullDownDistance","onRefresh","backgroundColor","_f","isPullable","children","_g","containerRef","useRef","childrenRef","pullDownRef","pullToRefreshThresholdBreached","isDragging","startY","currentY","useEffect","current","addEventListener","onTouchStart","passive","onTouchMove","onEnd","body","removeEventListener","initContainer","requestAnimationFrame","overflowX","transform","opacity","classList","remove","e","MouseEvent","pageY","TouchEvent","touches","isTreeScrollable","parentElement","target","getBoundingClientRect","top","add","toString","overflow","visibility","App","FAKE_LIST","useState","list","setList","setTimeout","map","item","index","key","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+PAGIA,E,4DAgBJ,SAASC,EAAaC,EAASC,GAC3B,IAXJ,SAA8BD,GAC1B,IAAIE,EAAeC,iBAAiBH,GAASI,UAC7C,OAAIJ,IAAYK,SAASC,kBAAqC,YAAjBJ,IAGxB,WAAjBA,GAA8C,SAAjBA,GAM5BK,CAAqBP,GACtB,OAAO,EAEX,GAAIC,IAAcH,EAAUU,KAExB,OADmBR,EAAQS,UAAYT,EAAQU,aACzBV,EAAQW,aAElC,GAAIV,IAAcH,EAAUc,GACxB,OAAOZ,EAAQS,UAAY,EAE/B,MAAM,IAAII,MAAM,yBAepB,SAASC,EAAYC,EAAKC,QACX,IAARA,IAAiBA,EAAM,IAC5B,IAAIC,EAAWD,EAAIC,SAEnB,GAAKF,GAA2B,qBAAbV,SAAnB,CAEA,IAAIa,EAAOb,SAASa,MAAQb,SAASc,qBAAqB,QAAQ,GAC9DC,EAAQf,SAASgB,cAAc,SACnCD,EAAME,KAAO,WAEI,QAAbL,GACEC,EAAKK,WACPL,EAAKM,aAAaJ,EAAOF,EAAKK,YAKhCL,EAAKO,YAAYL,GAGfA,EAAMM,WACRN,EAAMM,WAAWC,QAAUZ,EAE3BK,EAAMK,YAAYpB,SAASuB,eAAeb,MAhE9C,SAAWjB,GACPA,EAAUA,EAAS,IAAU,GAAK,KAClCA,EAAUA,EAAS,KAAW,GAAK,OAFvC,CAGGA,IAAcA,EAAY,KAkE7BgB,EADU,4/BAIV,IAAIe,EAAoB,WACpB,OAAQC,IAAMT,cAAc,MAAO,CAAEU,UAAW,gBAC5CD,IAAMT,cAAc,MAAO,MAC3BS,IAAMT,cAAc,MAAO,MAC3BS,IAAMT,cAAc,MAAO,MAC3BS,IAAMT,cAAc,MAAO,QAG/BW,EAAiB,WACjB,OAAQF,IAAMT,cAAc,MAAO,KAC/BS,IAAMT,cAAc,IAAK,KAAM,iDAIvCP,EADY,u9BAGZ,IAgIemB,EAhIK,SAAUC,GAC1B,IAAIC,EAAKD,EAAGE,kBAAmBA,OAA2B,IAAPD,EAAgBL,IAAMT,cAAcQ,EAAmB,MAAQM,EAAIE,EAAKH,EAAGI,eAAgBA,OAAwB,IAAPD,EAAgBP,IAAMT,cAAcW,EAAgB,MAAQK,EAAIE,EAAKL,EAAGM,kBAAmBA,OAA2B,IAAPD,EAAgB,GAAKA,EAAIE,EAAKP,EAAGQ,oBAAqBA,OAA6B,IAAPD,EAAgB,GAAKA,EAC/WE,EAAYT,EAAGS,UAAWC,EAAkBV,EAAGU,gBAAiBC,EAAKX,EAAGY,WAAYA,OAAoB,IAAPD,GAAuBA,EAAIE,EAAWb,EAAGa,SAAUC,EAAKd,EAAGH,UAAWA,OAAmB,IAAPiB,EAAgB,GAAKA,EACpMC,EAAeC,iBAAO,MACtBC,EAAcD,iBAAO,MACrBE,EAAcF,iBAAO,MACrBG,GAAiC,EACjCC,GAAa,EACbC,EAAS,EACTC,EAAW,EACfC,qBAAU,WACN,GAAKX,GAAeK,GAAgBA,EAAYO,QAShD,OAPAP,EAAYO,QAAQC,iBAAiB,aAAcC,EAAc,CAAEC,SAAS,IAC5EV,EAAYO,QAAQC,iBAAiB,YAAaC,GAClDT,EAAYO,QAAQC,iBAAiB,YAAaG,EAAa,CAAED,SAAS,IAC1EV,EAAYO,QAAQC,iBAAiB,YAAaG,GAClDX,EAAYO,QAAQC,iBAAiB,WAAYI,GACjDZ,EAAYO,QAAQC,iBAAiB,UAAWI,GAChD1D,SAAS2D,KAAKL,iBAAiB,aAAcI,GACtC,WACEjB,GAAeK,GAAgBA,EAAYO,UAEhDP,EAAYO,QAAQO,oBAAoB,aAAcL,GACtDT,EAAYO,QAAQO,oBAAoB,YAAaL,GACrDT,EAAYO,QAAQO,oBAAoB,YAAaH,GACrDX,EAAYO,QAAQO,oBAAoB,YAAaH,GACrDX,EAAYO,QAAQO,oBAAoB,WAAYF,GACpDZ,EAAYO,QAAQO,oBAAoB,UAAWF,GACnD1D,SAAS2D,KAAKC,oBAAoB,aAAcF,OAErD,CAACjB,EAAYH,EAAWH,EAAmBE,IAC9Ce,qBAAU,WACNS,MACD,CAACnB,IACJ,IAAImB,EAAgB,WAChBC,uBAAsB,WACdhB,EAAYO,UACZP,EAAYO,QAAQtC,MAAMgD,UAAY,SACtCjB,EAAYO,QAAQtC,MAAMhB,UAAY,OAEtC+C,EAAYO,QAAQtC,MAAMiD,UAAY,uBAEtCjB,EAAYM,UACZN,EAAYM,QAAQtC,MAAMkD,QAAU,KAEpCrB,EAAaS,UACbT,EAAaS,QAAQa,UAAUC,OAAO,0BACtCvB,EAAaS,QAAQa,UAAUC,OAAO,sBAI9CZ,EAAe,SAAUa,GACzBnB,GAAa,EACTmB,aAAaC,aACbnB,EAASkB,EAAEE,OAEXF,aAAaG,aACbrB,EAASkB,EAAEI,QAAQ,GAAGF,OAE1BnB,EAAWD,EAEI,eAAXkB,EAAEnD,MAvHd,SAASwD,EAAiB9E,EAASC,GAC/B,QAAIF,EAAaC,EAASC,IAGG,MAAzBD,EAAQ+E,eAGLD,EAAiB9E,EAAQ+E,cAAe9E,GAgHZ6E,CAAiBL,EAAEO,OAAQlF,EAAUc,KAIhEuC,EAAYO,QAAQuB,wBAAwBC,IAAM,IAGtD5B,GAAa,IAEbQ,EAAc,SAAUW,GACnBnB,IAIDE,EADAiB,aAAaG,WACFH,EAAEI,QAAQ,GAAGF,MAGbF,EAAEE,MAEjB1B,EAAaS,QAAQa,UAAUY,IAAI,iBAC/B3B,EAAWD,EACXD,GAAa,GAIbE,EAAWD,GAAUf,GACrBc,GAAa,EACbD,GAAiC,EACjCJ,EAAaS,QAAQa,UAAUC,OAAO,iBACtCvB,EAAaS,QAAQa,UAAUY,IAAI,4BAGnC9B,GAAiC,EACjCJ,EAAaS,QAAQa,UAAUC,OAAO,2BAGtChB,EAAWD,EAASb,IAGxBU,EAAYM,QAAQtC,MAAMkD,UAAYd,EAAWD,GAAU,IAAI6B,WAC/DjC,EAAYO,QAAQtC,MAAMiE,SAAW,UACrClC,EAAYO,QAAQtC,MAAMiD,UAAY,mBAAqBb,EAAWD,GAAU,MAChFH,EAAYM,QAAQtC,MAAMkE,WAAa,cAEvCvB,EAAQ,WAKR,GAJAT,GAAa,EACbC,EAAS,EACTC,EAAW,GAENH,EAGD,OAFAD,EAAYM,QAAQtC,MAAMkE,WAAa,cACvCpB,IAGJf,EAAYO,QAAQtC,MAAMiE,SAAW,UACrClC,EAAYO,QAAQtC,MAAMiD,UAAY,kBAAoB7B,EAAoB,MAC9Ea,GAAiC,EACjCV,KAEJ,OAAQb,IAAMT,cAAc,MAAO,CAAEU,UAAW,OAASA,EAAWX,MAAO,CAAEwB,gBAAiBA,GAAmB5B,IAAKiC,GAClHnB,IAAMT,cAAc,MAAO,CAAEU,UAAW,iBAAkBf,IAAKoC,GAC3DtB,IAAMT,cAAc,MAAO,CAAEU,UAAW,2BAA6BK,GACrEN,IAAMT,cAAc,MAAO,CAAEU,UAAW,6BAA+BO,IAC3ER,IAAMT,cAAc,MAAO,CAAEU,UAAW,gBAAiBf,IAAKmC,GAAeJ,KCtLtEwC,EA/BO,WAEpB,IAAMC,EAAY,CAAC,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,OAFnF,EAGFC,mBAAmBD,GAHjB,mBAGnBE,EAHmB,KAGbC,EAHa,KAW1B,OACE,yBAAK5D,UAAU,OACb,kBAAC,EAAD,CAAeY,UARA,WACjBiD,YAAW,WACTD,EAAQ,GAAD,mBAAKD,GAASF,MACpB,QAMC,oCACE,4BAAQzD,UAAU,cAAlB,mBACA,yBAAKA,UAAU,iBACb,4BACG2D,EAAKG,KAAI,SAACC,EAAcC,GAAf,OACR,wBAAIC,IAAKD,GACNA,EADH,MACaD,YCZTG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASlG,SAASmG,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.028fee3e.chunk.js","sourcesContent":["/* eslint-disable */\nimport React, { useRef, useEffect } from 'react';\n\nvar DIRECTION;\r\n(function (DIRECTION) {\r\n    DIRECTION[DIRECTION[\"UP\"] = -1] = \"UP\";\r\n    DIRECTION[DIRECTION[\"DOWN\"] = 1] = \"DOWN\";\r\n})(DIRECTION || (DIRECTION = {}));\n\nfunction isOverflowScrollable(element) {\r\n    var overflowType = getComputedStyle(element).overflowY;\r\n    if (element === document.scrollingElement && overflowType === 'visible') {\r\n        return true;\r\n    }\r\n    if (overflowType !== 'scroll' && overflowType !== 'auto') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isScrollable(element, direction) {\r\n    if (!isOverflowScrollable(element)) {\r\n        return false;\r\n    }\r\n    if (direction === DIRECTION.DOWN) {\r\n        var bottomScroll = element.scrollTop + element.clientHeight;\r\n        return bottomScroll < element.scrollHeight;\r\n    }\r\n    if (direction === DIRECTION.UP) {\r\n        return element.scrollTop > 0;\r\n    }\r\n    throw new Error('unsupported direction');\r\n}\r\n/**\r\n * Returns whether a given element or any of its ancestors (up to rootElement) is scrollable in a given direction.\r\n */\r\nfunction isTreeScrollable(element, direction) {\r\n    if (isScrollable(element, direction)) {\r\n        return true;\r\n    }\r\n    if (element.parentElement == null) {\r\n        return false;\r\n    }\r\n    return isTreeScrollable(element.parentElement, direction);\r\n}\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".lds-ellipsis {\\n  display: inline-block;\\n  position: relative;\\n  width: 64px;\\n  height: 64px; }\\n\\n.lds-ellipsis div {\\n  position: absolute;\\n  top: 27px;\\n  width: 11px;\\n  height: 11px;\\n  border-radius: 50%;\\n  background: #363636;\\n  animation-timing-function: cubic-bezier(0, 1, 1, 0); }\\n\\n.lds-ellipsis div:nth-child(1) {\\n  left: 6px;\\n  animation: lds-ellipsis1 0.6s infinite; }\\n\\n.lds-ellipsis div:nth-child(2) {\\n  left: 6px;\\n  animation: lds-ellipsis2 0.6s infinite; }\\n\\n.lds-ellipsis div:nth-child(3) {\\n  left: 26px;\\n  animation: lds-ellipsis2 0.6s infinite; }\\n\\n.lds-ellipsis div:nth-child(4) {\\n  left: 45px;\\n  animation: lds-ellipsis3 0.6s infinite; }\\n\\n@keyframes lds-ellipsis1 {\\n  0% {\\n    transform: scale(0); }\\n  100% {\\n    transform: scale(1); } }\\n\\n@keyframes lds-ellipsis3 {\\n  0% {\\n    transform: scale(1); }\\n  100% {\\n    transform: scale(0); } }\\n\\n@keyframes lds-ellipsis2 {\\n  0% {\\n    transform: translate(0, 0); }\\n  100% {\\n    transform: translate(19px, 0); } }\\n\";\nstyleInject(css);\n\n// Source: https://loading.io/css/\r\nvar RefreshingContent = function () {\r\n    return (React.createElement(\"div\", { className: \"lds-ellipsis\" },\r\n        React.createElement(\"div\", null),\r\n        React.createElement(\"div\", null),\r\n        React.createElement(\"div\", null),\r\n        React.createElement(\"div\", null)));\r\n};\n\nvar PullingContent = function () {\r\n    return (React.createElement(\"div\", null,\r\n        React.createElement(\"p\", null, \"\\u21A7\\u00A0\\u00A0pull to refresh\\u00A0\\u00A0\\u21A7\")));\r\n};\n\nvar css$1 = \".ptr,\\n.ptr__children {\\n  height: 100%;\\n  overflow: hidden;\\n  -webkit-overflow-scrolling: touch;\\n  position: relative;\\n  z-index: 1; }\\n\\n.ptr__children,\\n.ptr__pull-down {\\n  transition: transform 0.2s cubic-bezier(0, 0, 0.31, 1); }\\n\\n.ptr__pull-down {\\n  position: absolute;\\n  overflow: hidden;\\n  left: 0;\\n  right: 0;\\n  top: 0;\\n  visibility: hidden;\\n  text-align: center; }\\n  .ptr__pull-down > div {\\n    margin: 0 auto; }\\n  .ptr__pull-down > .ptr__pull-down--loading {\\n    display: none;\\n    text-align: center;\\n    margin: 0 auto; }\\n  .ptr__pull-down > .ptr__pull-down--pull-more {\\n    display: none;\\n    text-align: center;\\n    margin: 0 auto; }\\n\\n.ptr--dragging.ptr--treshold-breached .ptr__pull-down--pull-more {\\n  display: none; }\\n\\n.ptr--dragging .ptr__pull-down--pull-more {\\n  display: block; }\\n\\n.ptr--treshold-breached .ptr__pull-down {\\n  opacity: 1 !important; }\\n\\n.ptr--treshold-breached .ptr__pull-down--loading {\\n  display: block; }\\n\";\nstyleInject(css$1);\n\nvar PullToRefresh = function (_a) {\r\n    var _b = _a.refreshingContent, refreshingContent = _b === void 0 ? React.createElement(RefreshingContent, null) : _b, _c = _a.pullingContent, pullingContent = _c === void 0 ? React.createElement(PullingContent, null) : _c, _d = _a.pullDownThreshold, pullDownThreshold = _d === void 0 ? 67 : _d, _e = _a.maxPullDownDistance, maxPullDownDistance = _e === void 0 ? 95 : _e, // max distance to scroll to trigger refresh\r\n    onRefresh = _a.onRefresh, backgroundColor = _a.backgroundColor, _f = _a.isPullable, isPullable = _f === void 0 ? true : _f, children = _a.children, _g = _a.className, className = _g === void 0 ? '' : _g;\r\n    var containerRef = useRef(null);\r\n    var childrenRef = useRef(null);\r\n    var pullDownRef = useRef(null);\r\n    var pullToRefreshThresholdBreached = false;\r\n    var isDragging = false;\r\n    var startY = 0;\r\n    var currentY = 0;\r\n    useEffect(function () {\r\n        if (!isPullable || !childrenRef || !childrenRef.current)\r\n            return;\r\n        childrenRef.current.addEventListener('touchstart', onTouchStart, { passive: true });\r\n        childrenRef.current.addEventListener('mousedown', onTouchStart);\r\n        childrenRef.current.addEventListener('touchmove', onTouchMove, { passive: false });\r\n        childrenRef.current.addEventListener('mousemove', onTouchMove);\r\n        childrenRef.current.addEventListener('touchend', onEnd);\r\n        childrenRef.current.addEventListener('mouseup', onEnd);\r\n        document.body.addEventListener('mouseleave', onEnd);\r\n        return function () {\r\n            if (!isPullable || !childrenRef || !childrenRef.current)\r\n                return;\r\n            childrenRef.current.removeEventListener('touchstart', onTouchStart);\r\n            childrenRef.current.removeEventListener('mousedown', onTouchStart);\r\n            childrenRef.current.removeEventListener('touchmove', onTouchMove);\r\n            childrenRef.current.removeEventListener('mousemove', onTouchMove);\r\n            childrenRef.current.removeEventListener('touchend', onEnd);\r\n            childrenRef.current.removeEventListener('mouseup', onEnd);\r\n            document.body.removeEventListener('mouseleave', onEnd);\r\n        };\r\n    }, [isPullable, onRefresh, pullDownThreshold, maxPullDownDistance]);\r\n    useEffect(function () {\r\n        initContainer();\r\n    }, [children]);\r\n    var initContainer = function () {\r\n        requestAnimationFrame(function () {\r\n            if (childrenRef.current) {\r\n                childrenRef.current.style.overflowX = 'hidden';\r\n                childrenRef.current.style.overflowY = 'auto';\r\n                // childrenRef.current.style.overflow = 'auto';\r\n                childrenRef.current.style.transform = \"translate(0px, 0px)\";\r\n            }\r\n            if (pullDownRef.current) {\r\n                pullDownRef.current.style.opacity = '0';\r\n            }\r\n            if (containerRef.current) {\r\n                containerRef.current.classList.remove('ptr--treshold-breached');\r\n                containerRef.current.classList.remove('ptr--dragging');\r\n            }\r\n        });\r\n    };\r\n    var onTouchStart = function (e) {\r\n        isDragging = false;\r\n        if (e instanceof MouseEvent) {\r\n            startY = e.pageY;\r\n        }\r\n        if (e instanceof TouchEvent) {\r\n            startY = e.touches[0].pageY;\r\n        }\r\n        currentY = startY;\r\n        // Check if element can be scrolled\r\n        if (e.type === 'touchstart' && isTreeScrollable(e.target, DIRECTION.UP)) {\r\n            return;\r\n        }\r\n        // Top non visible so cancel\r\n        if (childrenRef.current.getBoundingClientRect().top < 0) {\r\n            return;\r\n        }\r\n        isDragging = true;\r\n    };\r\n    var onTouchMove = function (e) {\r\n        if (!isDragging) {\r\n            return;\r\n        }\r\n        if (e instanceof TouchEvent) {\r\n            currentY = e.touches[0].pageY;\r\n        }\r\n        else {\r\n            currentY = e.pageY;\r\n        }\r\n        containerRef.current.classList.add('ptr--dragging');\r\n        if (currentY < startY) {\r\n            isDragging = false;\r\n            return;\r\n        }\r\n        // Limit to trigger refresh has been breached\r\n        if (currentY - startY >= pullDownThreshold) {\r\n            isDragging = true;\r\n            pullToRefreshThresholdBreached = true;\r\n            containerRef.current.classList.remove('ptr--dragging');\r\n            containerRef.current.classList.add('ptr--treshold-breached');\r\n        }\r\n        else {\r\n            pullToRefreshThresholdBreached = false;\r\n            containerRef.current.classList.remove('ptr--treshold-breached');\r\n        }\r\n        // maxPullDownDistance breached, stop the animation\r\n        if (currentY - startY > maxPullDownDistance) {\r\n            return;\r\n        }\r\n        pullDownRef.current.style.opacity = ((currentY - startY) / 65).toString();\r\n        childrenRef.current.style.overflow = 'visible';\r\n        childrenRef.current.style.transform = \"translate(0px, \" + (currentY - startY) + \"px)\";\r\n        pullDownRef.current.style.visibility = 'visible';\r\n    };\r\n    var onEnd = function () {\r\n        isDragging = false;\r\n        startY = 0;\r\n        currentY = 0;\r\n        // Container has not been dragged enough, put it back to it's initial state\r\n        if (!pullToRefreshThresholdBreached) {\r\n            pullDownRef.current.style.visibility = 'hidden';\r\n            initContainer();\r\n            return;\r\n        }\r\n        childrenRef.current.style.overflow = 'visible';\r\n        childrenRef.current.style.transform = \"translate(0px, \" + pullDownThreshold + \"px)\";\r\n        pullToRefreshThresholdBreached = false;\r\n        onRefresh();\r\n    };\r\n    return (React.createElement(\"div\", { className: \"ptr \" + className, style: { backgroundColor: backgroundColor }, ref: containerRef },\r\n        React.createElement(\"div\", { className: \"ptr__pull-down\", ref: pullDownRef },\r\n            React.createElement(\"div\", { className: \"ptr__pull-down--loading\" }, refreshingContent),\r\n            React.createElement(\"div\", { className: \"ptr__pull-down--pull-more\" }, pullingContent)),\r\n        React.createElement(\"div\", { className: \"ptr__children\", ref: childrenRef }, children)));\r\n};\n\nexport default PullToRefresh;\n","import React, { useState } from 'react';\nimport './App.css';\nimport PullToRefresh from './pull-to-refresh';\n\nconst App: React.FC = () => {\n  // prettier-ignore\n  const FAKE_LIST = ['foo','bar','baz','foo','foo','bar','baz','foo','foo','bar','baz','foo','foo','bar','baz','foo'];\n  const [list, setList] = useState<string[]>(FAKE_LIST);\n\n  const getNewData = (): void => {\n    setTimeout(() => {\n      setList([...list, ...FAKE_LIST]);\n    }, 1500);\n  };\n\n  return (\n    <div className=\"App\">\n      <PullToRefresh onRefresh={getNewData}>\n        <>\n          <header className=\"App-header\">Pull To Refresh</header>\n          <div className=\"App-container\">\n            <ul>\n              {list.map((item: string, index: number) => (\n                <li key={index}>\n                  {index} - {item}\n                </li>\n              ))}\n            </ul>\n          </div>\n        </>\n      </PullToRefresh>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}